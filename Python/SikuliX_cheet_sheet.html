<!DOCTYPE html>
<html>
<head>
<title>SikuliX_cheet_sheet.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="sikulixcheetsheet">SikuliX_Cheet_Sheet</h1>
<h2 id="%E7%94%BB%E5%83%8F%E3%82%92%E3%82%AF%E3%83%AA%E3%83%83%E3%82%AF%E3%81%99%E3%82%8B">画像をクリックする</h2>
<h3 id="%E3%81%82%E3%82%8B%E7%94%BB%E5%83%8F%E3%82%92%E4%B8%80%E5%9B%9E%E3%82%AF%E3%83%AA%E3%83%83%E3%82%AF%E3%81%99%E3%82%8B">ある画像を一回クリックする</h3>
<ul>
<li>最も基本</li>
</ul>
<pre class="hljs"><code><div>click(<span class="hljs-string">'画像名'</span>)
</div></code></pre>
<ul>
<li>画像から一定座標動かしたところをクリックすることも可能</li>
<li>SikuliX上で画像をクリックし、ターゲットオフセットを選択する</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># 画像から右に10, 下に10ピクセル動かしたところをクリック</span>
click(Pattern(<span class="hljs-string">'画像名'</span>).targetOffset(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>))
</div></code></pre>
<h3 id="%E7%94%BB%E5%83%8F%E3%81%8C%E6%B6%88%E3%81%88%E3%82%8B%E3%81%BE%E3%81%A7%E7%94%BB%E5%83%8F%E3%82%92%E3%82%AF%E3%83%AA%E3%83%83%E3%82%AF%E3%81%97%E7%B6%9A%E3%81%91%E3%82%8B">画像が消えるまで画像をクリックし続ける</h3>
<ul>
<li>clickはたまに失敗することを考慮したロジック</li>
<li>OKボタンの押下、チェックボックスをすべて外す、ウィンドウをすべて閉じる等応用範囲が広い</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    remove_img_click(<span class="hljs-string">'画像名'</span>)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_img_click</span><span class="hljs-params">(img)</span>:</span>
    <span class="hljs-keyword">while</span> exists(img):
        click(img)
        sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 1回クリックするごとに1秒休ませて、フリーズ回避</span>


main()
</div></code></pre>
<ul>
<li>指定回数動かしたら止めたい場合はこっち</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    remove_img_click(<span class="hljs-string">'画像名'</span>, <span class="hljs-number">10</span>)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_img_click</span><span class="hljs-params">(img, max_cnt=float<span class="hljs-params">(<span class="hljs-string">'inf'</span>)</span>)</span>:</span>
    cnt = <span class="hljs-number">-1</span>
    <span class="hljs-keyword">while</span> exists(img):
        cnt += <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> cnt &gt; max_cnt:
            <span class="hljs-keyword">return</span>
        click(img)
        sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 1回クリックするごとに1秒休ませて、フリーズ回避</span>


main()
</div></code></pre>
<h3 id="%E7%94%BB%E5%83%8F%E3%81%8C%E5%AD%98%E5%9C%A8%E3%81%99%E3%82%8B%E9%99%90%E3%82%8A%E3%82%AF%E3%83%AA%E3%83%83%E3%82%AF%E3%81%97%E7%B6%9A%E3%81%91%E3%82%8B">画像が存在する限りクリックし続ける</h3>
<ul>
<li>画像Aがある(あった)場所を、画像Bが消えるまでクリックし続ける</li>
<li>まれに使う機会がある</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    mat = find(<span class="hljs-string">'クリックする対象'</span>)
    x, y = mat.getX(), mat.getY()
    click_while_exists(x, y, <span class="hljs-string">'消えるまでクリックする対象の画像'</span>)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">click_while_exists</span><span class="hljs-params">(x, y, img)</span>:</span>
    <span class="hljs-keyword">while</span> exists(img):
        click(Location(x, y))
        sleep(<span class="hljs-number">1</span>)


main()
</div></code></pre>
<h3 id="%E3%81%82%E3%82%8B%E7%94%BB%E5%83%8F%E3%81%8B%E3%82%89%E4%B8%80%E5%AE%9A%E9%96%93%E9%9A%94%E3%81%9A%E3%82%89%E3%81%97%E3%81%9F%E5%A0%B4%E6%89%80%E3%82%92%E9%80%A3%E7%B6%9A%E3%82%AF%E3%83%AA%E3%83%83%E3%82%AF%E3%81%99%E3%82%8B">ある画像から、一定間隔ずらした場所を連続クリックする</h3>
<ul>
<li>RPAでは極力、画像認識の回数を減らしたい</li>
<li>リスト上に入力欄が列挙されている場合など、等間隔にクリックする箇所が並んでいる場合は一定間隔ずつずらしてクリックする</li>
<li>出現頻度は低い</li>
</ul>
<pre class="hljs"><code><div>dx, dy = <span class="hljs-number">0</span>, <span class="hljs-number">10</span>
cnt = <span class="hljs-number">10</span>
mat = find(<span class="hljs-string">'ある画像'</span>)
x, y = mat.getX(), mat.getY()
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(cnt):
    cur_x, cur_y = x + dx*i, y + dy*i
    click(Location(cur_x, cur_y))
</div></code></pre>
<h2 id="%E7%94%BB%E5%83%8F%E3%81%8C%E5%AD%98%E5%9C%A8%E3%81%99%E3%82%8B%E3%81%8B%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B">画像が存在するか確認する</h2>
<h3 id="%E7%94%BB%E5%83%8F%E3%81%8C%E3%81%82%E3%82%8B%E3%81%A8%E3%81%8D%E3%81%A8%E3%81%AA%E3%81%84%E3%81%A8%E3%81%8D%E3%81%A7%E5%88%86%E5%B2%90">画像があるときとないときで分岐</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> exists(<span class="hljs-string">'画像名'</span>):
    myfnc1()  <span class="hljs-comment"># 別途作成した処理1</span>
<span class="hljs-keyword">else</span>:
    myfnc2()
</div></code></pre>
<h3 id="%E7%94%BB%E5%83%8F%E3%81%8C%E5%87%BA%E3%81%A6%E3%81%8F%E3%82%8B%E3%81%BE%E3%81%A7%E5%BE%85%E3%81%A4">画像が出てくるまで待つ</h3>
<pre class="hljs"><code><div>wait(<span class="hljs-string">'画像名'</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment"># 画像が表示されるまで10秒待つ。</span>
</div></code></pre>
<h3 id="%E7%94%BB%E5%83%8F%E3%82%92%E8%A6%8B%E3%81%A4%E3%81%91%E3%82%8B">画像を見つける</h3>
<ul>
<li>画像を見つけて、Matchとして返す</li>
<li>応用の幅が広いが、そんなに使わない</li>
</ul>
<pre class="hljs"><code><div>mat = find(<span class="hljs-string">'画像名'</span>)
<span class="hljs-keyword">print</span> mat.getX()  <span class="hljs-comment"># マッチした画像のx座標を出力する</span>
</div></code></pre>
<pre class="hljs"><code><div>mat_gen = findAll(<span class="hljs-string">'画像名'</span>)
<span class="hljs-keyword">for</span> mat <span class="hljs-keyword">in</span> mat_gen:
    <span class="hljs-keyword">print</span> mat.getX()  <span class="hljs-comment"># マッチした全ての画像のx座標を出力する</span>
</div></code></pre>
<h3 id="%E3%83%9E%E3%83%83%E3%83%81%E3%81%97%E3%81%9F%E7%94%BB%E5%83%8F%E3%82%92%E4%B8%8A%E3%81%8B%E3%82%89%E9%A0%86%E7%95%AA%E3%81%AB%E3%82%AF%E3%83%AA%E3%83%83%E3%82%AF%E3%81%99%E3%82%8B">マッチした画像を上から順番にクリックする</h3>
<ul>
<li>findAllの応用例</li>
</ul>
<pre class="hljs"><code><div>mat_list = list(findAll(<span class="hljs-string">'画像名'</span>))
mat_list.sort(key=<span class="hljs-keyword">lambda</span> mat: mat.getY())
<span class="hljs-keyword">for</span> mat <span class="hljs-keyword">in</span> mat_list:
    x, y = mat.getX(), mat.getY()
    click(Location(x, y))
</div></code></pre>
<h2 id="%E5%87%BA%E5%8A%9B%E3%81%99%E3%82%8B">出力する</h2>
<h3 id="%E3%82%AD%E3%83%BC%E3%83%9C%E3%83%BC%E3%83%89%E3%81%8B%E3%82%89%E5%85%A5%E5%8A%9B%E3%81%99%E3%82%8B">キーボードから入力する</h3>
<p>1文字～数文字の入力に適している</p>
<pre class="hljs"><code><div>type(<span class="hljs-string">'a'</span>)  <span class="hljs-comment"># キーボード[a]をtype</span>
type(Key.Home)  <span class="hljs-comment"># キーボード[Home]をtype</span>
type(<span class="hljs-string">'abc123'</span>)  <span class="hljs-comment"># キーボードa, b, c, 1, 2, 3を順にtype</span>
type(<span class="hljs-string">'s'</span>, Key.CTRL)  <span class="hljs-comment"># Ctrl+[s]を入力</span>
</div></code></pre>
<h3 id="%E3%83%9A%E3%83%BC%E3%82%B9%E3%83%88%E3%81%99%E3%82%8B">ペーストする</h3>
<p>複数文字をまとめて張り付ける</p>
<pre class="hljs"><code><div>text = <span class="hljs-string">'Hello World'</span>
paste(text)
</div></code></pre>
<h3 id="%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9%E3%82%92%E4%BD%9C%E3%82%8B">メッセージボックスを作る</h3>
<pre class="hljs"><code><div>text = <span class="hljs-string">'Hello World'</span>
pop(text)
</div></code></pre>
<h3 id="%E6%A8%99%E6%BA%96%E5%87%BA%E5%8A%9B">標準出力</h3>
<ul>
<li>デバッグするときに使う</li>
</ul>
<pre class="hljs"><code><div>text = <span class="hljs-string">'Hello World'</span>
<span class="hljs-keyword">print</span> text
</div></code></pre>
<h2 id="%E5%85%A5%E5%8A%9B%E3%81%99%E3%82%8B">入力する</h2>
<h3 id="%E3%81%AF%E3%81%84%E3%81%8B%E3%81%84%E3%81%84%E3%81%88%E3%81%8B">はいかいいえか</h3>
<ul>
<li>はい、いいえからなる入力ボックスを作る</li>
</ul>
<pre class="hljs"><code><div>flag = popAsc(<span class="hljs-string">u'処理を実行しますか'</span>)
<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> flag:
    <span class="hljs-keyword">return</span>
</div></code></pre>
<h3 id="%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E5%A0%B4%E6%89%80%E3%81%AE%E5%85%A5%E5%8A%9B">ファイルの場所の入力</h3>
<pre class="hljs"><code><div>csvPath = popFile(<span class="hljs-string">u'対象のcsvデータを指定してください'</span>)
</div></code></pre>
<h3 id="%E4%BB%BB%E6%84%8F%E3%81%AE%E6%96%87%E5%AD%97%E5%88%97%E3%81%AE%E5%85%A5%E5%8A%9B">任意の文字列の入力</h3>
<pre class="hljs"><code><div>text = input(<span class="hljs-string">u'出力したい文字列を入力してください'</span>)
<span class="hljs-keyword">print</span> text
</div></code></pre>
<h3 id="csv%E3%82%92%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%80">csvを読み込む</h3>
<ul>
<li>Pythonの標準のcsv読み込み機能と同一</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> csv


csvPath = popFile(<span class="hljs-string">u'対象のcsvデータを指定してください'</span>)
<span class="hljs-keyword">with</span> open(csvPath, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:
    reader = csv.reader(f, delimiter=<span class="hljs-string">','</span>, quotechar=<span class="hljs-string">'"'</span>)
    header = next(reader)
    <span class="hljs-keyword">for</span> row_dat <span class="hljs-keyword">in</span> reader:  <span class="hljs-comment"># 1行ずつ処理していく</span>
        <span class="hljs-keyword">print</span> row_dat[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 1列目のデータ</span>
        <span class="hljs-keyword">print</span> row_dat[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 2列目のデータ</span>
        <span class="hljs-keyword">print</span> row_dat[<span class="hljs-number">2</span>]  <span class="hljs-comment"># 3列目のデータ</span>
</div></code></pre>
<h2 id="%E8%A8%AD%E8%A8%88%E3%81%99%E3%82%8B-%E5%9F%BA%E6%9C%AC">設計する-基本</h2>
<ul>
<li>今まで挙げた機能を組み合わせて、プログラムの設計をしていく</li>
</ul>
<h3 id="%E5%A4%89%E6%95%B0%E3%82%92%E4%BD%BF%E3%81%86">変数を使う</h3>
<ul>
<li>同じ画像がたくさん出てくる場合は、変数にしてまとめる</li>
<li>これだと、画像Aがちょっと変わると5箇所メンテが必要となる</li>
</ul>
<pre class="hljs"><code><div>click(<span class="hljs-string">'画像A'</span>)
click(<span class="hljs-string">'画像A'</span>)
click(<span class="hljs-string">'画像A'</span>)
click(<span class="hljs-string">'画像A'</span>)
click(<span class="hljs-string">'画像A'</span>)
</div></code></pre>
<ul>
<li>変数を使うことで、コードは1行長くなるがメンテナンス性は各段に向上する</li>
</ul>
<pre class="hljs"><code><div>img_A = <span class="hljs-string">'画像A'</span>
click(img_A)
click(img_A)
click(img_A)
click(img_A)
click(img_A)
</div></code></pre>
<ul>
<li>ただし、変数を設定している個所が遠いと、見通しが悪くなるので注意する</li>
<li>設定する系統の変数は最初に宣言するのが通常のPythonでは鉄則だが</li>
<li>SikuliXの、画面上に画像を表示させる仕様上、変数の宣言をあえて遅らせるのも手である</li>
<li>コーディングスタイルは開発環境によっても臨機応変に変える必要がある</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># 悪い例: 普通のPythonならそんなに悪くないけど</span>
img_A = <span class="hljs-string">'画像A'</span>
<span class="hljs-comment"># ～処理～</span>
<span class="hljs-comment"># (中略　100行とか、1画面に収まらない量のプログラム)</span>
click(img_A)  <span class="hljs-comment"># 記事の都合上省略しているが、</span>
click(img_A)  <span class="hljs-comment"># img_A = '画像A'と、click(img_A)の間に</span>
click(img_A)  <span class="hljs-comment"># 間が空きすぎて1画面に収まらない場合</span>
click(img_A)  <span class="hljs-comment"># ここだけ見ても何してるのかわからず望ましくない</span>
click(img_A)
</div></code></pre>
<h3 id="%E3%83%AB%E3%83%BC%E3%83%97%E3%82%92%E4%BD%BF%E3%81%86">ループを使う</h3>
<ul>
<li>同じ処理を繰り返しているところは、for文、while文を使い重複を減らす</li>
</ul>
<pre class="hljs"><code><div>click(<span class="hljs-string">'画像A'</span>)
click(<span class="hljs-string">'画像A'</span>)
click(<span class="hljs-string">'画像A'</span>)
click(<span class="hljs-string">'画像A'</span>)
click(<span class="hljs-string">'画像A'</span>)
</div></code></pre>
<ul>
<li>これは次のようにする</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):
    click(<span class="hljs-string">'画像A'</span>)
</div></code></pre>
<h3 id="%E9%96%A2%E6%95%B0%E3%82%92%E4%BD%BF%E3%81%86">関数を使う</h3>
<ul>
<li>同じ処理をしている個所はまとめて、1つの関数にする</li>
</ul>
<pre class="hljs"><code><div>click(<span class="hljs-string">'画像A'</span>)
wait(<span class="hljs-string">'画像B'</span>, <span class="hljs-number">10</span>)
myfnc1()
click(<span class="hljs-string">'画像A'</span>)
wait(<span class="hljs-string">'画像B'</span>, <span class="hljs-number">10</span>)
myfnc2()
click(<span class="hljs-string">'画像A'</span>)  <span class="hljs-comment"># この処理が重複しているので良くない</span>
wait(<span class="hljs-string">'画像B'</span>, <span class="hljs-number">10</span>)
myfnc3()
</div></code></pre>
<ul>
<li>次のように、自作関数wait_image_Bを作り、重複を減らす</li>
</ul>
<pre class="hljs"><code><div>wait_image_B()
myfnc1()
wait_image_B()
myfnc2()
wait_image_B()
myfnc3()

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait_image_B</span><span class="hljs-params">()</span>:</span>
    click(<span class="hljs-string">'画像A'</span>)
    wait(<span class="hljs-string">'画像B'</span>, <span class="hljs-number">10</span>)
</div></code></pre>
<ul>
<li>さらにfor文を使い縮めることも可能
<ul>
<li>かえってメンテナンス性が落ちるケースもあるので注意</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>job_list = [myfnc1, myfnc2, myfnc3]
<span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> job_list:
    wait_image_B()
    job()

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait_image_B</span><span class="hljs-params">()</span>:</span>
    click(<span class="hljs-string">'画像A'</span>)
    wait(<span class="hljs-string">'画像B'</span>, <span class="hljs-number">10</span>)
</div></code></pre>
<h3 id="%E5%A4%89%E6%95%B0%E3%82%92%E3%81%BE%E3%81%A8%E3%82%81%E3%82%8B">変数をまとめる</h3>
<ul>
<li>構造体を用いて、たくさんの変数をまとめて管理する</li>
<li>Pythonには構造体がないので、クラスかnamedtupleを用いる</li>
<li>変数が多くなりすぎると可読性が著しく下がるので、このようにまとめて管理するとよい</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># 軽量クラスによる方法</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.val1 = <span class="hljs-number">0</span>
        self.val2 = <span class="hljs-number">0</span>
        self.val3 = <span class="hljs-number">0</span>
        self.val4 = <span class="hljs-number">0</span>
        self.val5 = <span class="hljs-number">0</span>

cfg = Config()
cfg.val1 = <span class="hljs-number">10</span>  <span class="hljs-comment"># cfg.val1として10を編集</span>
cfg.val2 = <span class="hljs-number">20</span>  <span class="hljs-comment"># classの場合後から変更可能</span>
<span class="hljs-keyword">print</span> cfg.val1  <span class="hljs-comment"># 10を編集する</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment"># namedtupleによる方法</span>
<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple
Config = namedtuple(<span class="hljs-string">'Config'</span>, [<span class="hljs-string">'val1'</span>, <span class="hljs-string">'val2'</span>, <span class="hljs-string">'val3'</span>, <span class="hljs-string">'val4'</span>, <span class="hljs-string">'val5'</span>])

cfg = Config(val1=<span class="hljs-number">10</span>, val2=<span class="hljs-number">20</span>, val3=<span class="hljs-number">30</span>, val4=<span class="hljs-number">40</span>, val5=<span class="hljs-number">50</span>)
<span class="hljs-comment"># cfg = Config(10, 20, 30, 40, 50)  でも同じ</span>
<span class="hljs-keyword">print</span> cfg.val1  <span class="hljs-comment"># 10が出力される</span>
<span class="hljs-comment"># namedtupleは値の変更が不可なので安全性が高い</span>
<span class="hljs-comment"># cfg.val1 = 20 これはエラー</span>
</div></code></pre>
<h2 id="%E8%A8%AD%E8%A8%88%E3%81%99%E3%82%8B-%E5%BF%9C%E7%94%A8">設計する-応用</h2>
<h3 id="%E7%94%BB%E5%83%8F%E3%81%AE%E9%87%8D%E8%A4%87%E3%82%92%E3%81%AA%E3%81%8F%E3%81%99">画像の重複をなくす</h3>
<ul>
<li>画像認識は、ちょっとでも画像が変わると上手く動作しなくなる</li>
<li>例えば対象アプリのアップデートで画像がさし替わってしまうと、メンテナンスが発生する</li>
<li>そのメンテナンス量を極力抑えるために、SikuliXで使っている画像の数を極力減らす事が望ましい</li>
<li>同じ画像が2箇所出てきた場合、設計する-基本で挙げた内容を使って、画像の数を減らしていくこと</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfnc1</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># ～何かの処理～</span>
    click(<span class="hljs-string">'ホーム画面'</span>)  <span class="hljs-comment"># ホーム画面をクリックしてホームに戻る</span>
    <span class="hljs-comment"># ～何かの処理～</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfnc2</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># ～何かの処理～</span>
    click(<span class="hljs-string">'ホーム画面'</span>)  <span class="hljs-comment"># &lt;-myfnc1と重複</span>
    <span class="hljs-comment"># ～何かの処理～</span>
</div></code></pre>
<ul>
<li>プログラム全体を通してみて、同じ画像が2箇所出てきた場合は、次のようにまとめることを検討</li>
<li>同じ画像を使っている処理は、大抵、関数として切り出すに足る共通処理をしていることが多いので</li>
<li>関数として切り出すとプログラム全体として見通しが良くなる傾向にある</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfnc1</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># ～何かの処理～</span>
    back_home()
    <span class="hljs-comment"># ～何かの処理～</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfnc2</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># ～何かの処理～</span>
    back_home()
    <span class="hljs-comment"># ～何かの処理～</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">back_home</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># ホーム画面をクリックするという動作を</span>
    <span class="hljs-comment"># back homeという名前を付けて</span>
    <span class="hljs-comment"># ホーム画面に戻るという操作に抽象化できる</span>
    <span class="hljs-comment"># 加えて、使用する画像も減らせる</span>
    click(<span class="hljs-string">'ホーム画面'</span>)
</div></code></pre>
<ul>
<li>悪いアイデア</li>
<li>辞書を使って処理をまとめるのはPythonでは典型だが</li>
<li>SikuliXで画像をまとめるのは、画面上、画像を表示してくれなくなるので望ましくない</li>
<li>それ以外の方向で画像の重複を避けるように工夫しよう</li>
</ul>
<pre class="hljs"><code><div>img_of = {<span class="hljs-string">'home'</span>: <span class="hljs-string">'ホーム画面'</span>}

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfnc1</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># 悪い例</span>
    <span class="hljs-comment"># エラーが出たときに、毎回img_ofの定義を見ないといけなくなる</span>
    click(img_of[<span class="hljs-string">'home'</span>])  <span class="hljs-comment"># 処理も抽象化されておらず、何してるかわからない</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfnc2</span><span class="hljs-params">()</span>:</span>
    click(img_of[<span class="hljs-string">'home'</span>])
</div></code></pre>
<h3 id="%E7%94%BB%E5%83%8F%E5%87%A6%E7%90%86%E3%82%92%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84">画像処理を使わない</h3>
<ul>
<li>SikuliXは画像処理を得意とするアプリだが、極力画像処理をする個所は減らしたほうがいい</li>
<li>悪い例</li>
</ul>
<pre class="hljs"><code><div>click(<span class="hljs-string">'画像1'</span>)
type(<span class="hljs-string">'a'</span>)
click(<span class="hljs-string">'画像2'</span>)
type(<span class="hljs-string">'b'</span>)
click(<span class="hljs-string">'画像3'</span>)
type(<span class="hljs-string">'c'</span>)
click(<span class="hljs-string">'画像4'</span>)
type(<span class="hljs-string">'d'</span>)
</div></code></pre>
<ul>
<li>画像1をクリックした段階で、Tabキーを押すと次の入力欄に行ける場合、次のようにする</li>
</ul>
<pre class="hljs"><code><div>click(<span class="hljs-string">'画像1'</span>)
char_list = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]
<span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> char_list:
    type(char)
    type(Key.TAB)  <span class="hljs-comment"># 次の入力欄に</span>
</div></code></pre>
<ul>
<li>画像2～4の入力欄が等間隔で並んでいる場合は、次のようにする</li>
</ul>
<pre class="hljs"><code><div>mat = find(<span class="hljs-string">'画像1'</span>)
x, y = mat.getX(), mat.getY()
dx, dy = <span class="hljs-number">10</span>, <span class="hljs-number">0</span>  <span class="hljs-comment"># 右に10ピクセルずつ動かしながらクリック</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):
    click(Location(x + dx*i, y + dy*i))
</div></code></pre>
<h3 id="%E5%87%A6%E7%90%86%E3%82%92%E9%A0%86%E7%95%AA%E3%81%AB%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%99">処理を順番に繰り返す</h3>
<ul>
<li>myfnc1～3を順番に無限に繰り返す</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    myfnc1()
    myfnc2()
    myfnc3()
</div></code></pre>
<ul>
<li>myfnc1～3を10回繰り返す</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
    myfnc1()
    myfnc2()
    myfnc3()
</div></code></pre>
<h3 id="csv%E3%81%8B%E3%82%89%E8%AA%AD%E3%82%93%E3%81%A0%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AB%E5%BF%9C%E3%81%98%E3%81%A6%E5%87%A6%E7%90%86%E3%82%92%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%99">csvから読んだデータに応じて処理を繰り返す</h3>
<ul>
<li>csvから読んだデータを元に処理を順番に行う</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> csv
<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple
Condition = namedtuple(<span class="hljs-string">'Condition'</span>, [<span class="hljs-string">'val1'</span>, <span class="hljs-string">'val2'</span>, <span class="hljs-string">'val3'</span>])

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">for</span> cond <span class="hljs-keyword">in</span> gen_csv():  <span class="hljs-comment"># csvデータをcondに編集して繰り返す</span>
        myfnc1(cond)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_csv</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># csvの内容を1行ずつ読んで、Conditionに渡すジェネレータ</span>
    csvPath = popFile(<span class="hljs-string">u'対象のcsvデータを指定してください'</span>)
    <span class="hljs-keyword">with</span> open(csvPath, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:
        reader = csv.reader(f, delimiter=<span class="hljs-string">','</span>, quotechar=<span class="hljs-string">'"'</span>)
        header = next(reader)
        <span class="hljs-keyword">for</span> row_dat <span class="hljs-keyword">in</span> reader:  <span class="hljs-comment"># 1行ずつ処理していく</span>
            val1 = row_dat[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 1列目のデータ</span>
            val2 = row_dat[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 2列目のデータ</span>
            val3 = row_dat[<span class="hljs-number">2</span>]  <span class="hljs-comment"># 3列目のデータ</span>
            <span class="hljs-comment"># for文を回しても実装可能だが</span>
            <span class="hljs-comment"># 実務上は、各列ごとに型の変換やデータの加工が入る事が大半であり、</span>
            <span class="hljs-comment"># 1列ずつ列挙していくことになろう</span>
            cond = Condition(val1=val1, val2=val2, val3=val3)
            <span class="hljs-keyword">yield</span> cond  <span class="hljs-comment"># yieldで、condを一回返して、処理を一時停止</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfnc1</span><span class="hljs-params">(cond)</span>:</span>
    <span class="hljs-comment"># condの内容に応じた処理を実行</span>
    <span class="hljs-keyword">print</span> cond.val1
    <span class="hljs-keyword">print</span> cond.val2
    <span class="hljs-keyword">print</span> cond.val3


main()
</div></code></pre>
<h3 id="%E6%8C%87%E5%AE%9A%E6%99%82%E9%96%93%E9%96%93%E9%9A%94%E3%81%A7%E5%87%A6%E7%90%86%E3%82%92%E5%AE%9F%E8%A1%8C">指定時間間隔で処理を実行</h3>
<ul>
<li>処理を開始-&gt;次に実行開始する時間を登録-&gt;その時間まで待機</li>
<li>複数の処理がある場合は、開始時刻が早いものから順に行う</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> heapq
<span class="hljs-keyword">import</span> datetime


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># myfnc1は10分毎、myfnc2は20分事・・・に行う</span>
    job_list = [(myfnc1, datetime.timedelta(minutes=<span class="hljs-number">10</span>))
              , (myfnc2, datetime.timedelta(minutes=<span class="hljs-number">20</span>))
              , (myfnc3, datetime.timedelta(minutes=<span class="hljs-number">30</span>))]

    <span class="hljs-comment"># 優先度付きキューの初期化</span>
    que = []
    now_ = datetime.datetime.now()
    <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> job_list:
        que.append((now_, job))
    heapq.heapify(que)

    <span class="hljs-keyword">while</span> que:
        sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># フリーズ回避</span>
        now_ = datetime.datetime.now()
        <span class="hljs-keyword">if</span> que[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt; now_:
            <span class="hljs-comment"># 最も開始時刻が早いものが、現在時刻より小さい場合は処理開始</span>
            _, job = heapq.heappop(que)
            fnc, delta = job
            heapq.heappush(que, (now_+delta, job))
            fnc()

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfnc1</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">print</span> <span class="hljs-string">'1'</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfnc2</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">print</span> <span class="hljs-string">'2'</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfnc3</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">print</span> <span class="hljs-string">'3'</span>

main()
</div></code></pre>
<h2 id="%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E8%AA%AD%E3%82%80%E4%BD%9C%E3%82%8B">エラーを読む/作る</h2>
<h3 id="%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E8%AA%AD%E3%82%80">エラーを読む</h3>
<ul>
<li>RPAでは、画像が存在する／しないによって頻繁にエラーが発生する</li>
<li>したがって、エラーを読む能力も重要である</li>
<li>Pythonでは、Traceback機能があるため、エラーは非常に読みやすい</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    myfnc1()

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfnc1</span><span class="hljs-params">()</span>:</span>
    myfnc2()

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfnc2</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">print</span> <span class="hljs-number">1</span>/<span class="hljs-number">0</span>


main()
</div></code></pre>
<ul>
<li>このコードは、main-&gt;myfnc1-&gt;myfnc2と呼ばれ、myfnc2で初めてエラーとなる</li>
<li>エラー発生時には、myfnc2でエラーが発生しました、という情報だけでなく</li>
<li>mainのmyfnc1が読んだmyfnc2でエラーが発生したことが分かるようになっている</li>
</ul>
<blockquote>
<p>[error] --- Traceback --- error source first<br>
line: module ( function ) statement<br>
8: main (  myfnc2 )     print 1/0<br>
5: main (  myfnc1 )     myfnc2()<br>
2: main (  main )     myfnc1()<br>
11: main (  <module> )     main()<br>
[error] --- Traceback --- end --------------</p>
</blockquote>
<ul>
<li>したがって、Tracebackを読めば、どのタイミングでエラーが発生したか特定できるようになっている</li>
</ul>
<h3 id="%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E6%9B%B8%E3%81%8F">エラーを書く</h3>
<ul>
<li>自動化対象のアプリが警告を出しているとき等、自作のエラーを作りたいときがある</li>
<li>次のようにする</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># ～処理～</span>
<span class="hljs-keyword">if</span> exists(<span class="hljs-string">'Error_Image'</span>):
    <span class="hljs-keyword">raise</span> <span class="hljs-string">'Error Name'</span>
</div></code></pre>
<ul>
<li>raise句を使うことで、自作のエラー処理を新たに作ることができる</li>
</ul>
<h3 id="%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%A7%E8%90%BD%E3%81%A8%E3%81%99%E3%81%8B%E5%87%A6%E7%90%86%E3%82%92%E7%B6%9A%E8%A1%8C%E3%81%95%E3%81%9B%E3%82%8B%E3%81%8B">エラーで落とすか、処理を続行させるか</h3>
<ul>
<li>エラーが発生した時に、安全に停止させるのか、そのまま処理を続行させるのか</li>
<li>前者を「fail safe」、後者を「fail soft」という</li>
<li>fail safeのほうが安全だが、全てをfail safeにすると頻繁にエラーが発生し、機能しなくなる可能性がある</li>
<li>「画像を1回クリックして、あるべき画像が表示されてなかったら止める」はfail safeといえる</li>
<li>「画像が消えるまで画像をクリックし続ける」はfail softといえる</li>
<li>画像をクリックするのセクションで挙げたロジックと、前述のraiseを組み合わせて、fail safeとfail softのバランスを取るのがいいRPAを作るコツとなる</li>
</ul>
<h2 id="%E7%94%BB%E5%83%8F%E3%82%92%E5%B7%AE%E3%81%97%E6%9B%BF%E3%81%88%E3%82%8B">画像を差し替える</h2>
<ul>
<li>対象アプリのアップデートで画像がさし替わった時は、次のように対応する</li>
</ul>
<ol>
<li>SikuliXを動かす(この場合スローモーションで実行 機能も役立つ)</li>
<li>画像がないと、エラーになったところで止める(というより止まる)</li>
<li>エラーとなった個所について、その画像の名前を調べる(その行をコピーし、メモ帳に貼ると調べられる)</li>
<li>その画像を差し替える</li>
<li>3で特定した名前が、プログラム上のほかの個所にないかを調べ(Ctrl+[f] -&gt; Ctrl+[g])、同様に差し替えていく</li>
<li>上記1～5を繰り返す</li>
</ol>
<p>1, 2の回数を減らすためにも、使用する画像の枚数は少ないほうが良い
4の回数を減らすためにも、同じ画像を使用している個所は少ないほうが良い</p>

</body>
</html>
